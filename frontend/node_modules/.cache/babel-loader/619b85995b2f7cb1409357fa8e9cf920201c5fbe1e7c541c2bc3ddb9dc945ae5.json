{"ast":null,"code":"// funzione helper per effettuare richieste autenticata con il token jwt\nexport async function apiFetch(url, options = {}) {\n  // recupero il token dal localstorage\n  const token = localStorage.getItem('token');\n  console.log('Token inviato nella richiesta:', token);\n  // aggiungo l'header authorization se il token è presente\n  const headers = {\n    ...(options.headers || {}),\n    ...(token ? {\n      Authorization: `Bearer ${token}`\n    } : {})\n  };\n  // se c'è un body e non è già impostato, aggiungo content-type\n  if (options.body && !headers['Content-Type']) {\n    headers['Content-Type'] = 'application/json';\n  }\n  const response = await fetch(url, {\n    ...options,\n    headers\n  });\n  const contentType = response.headers.get(\"content-type\");\n  if (!response.ok) {\n    // provo a leggere json, altrimenti testo\n    let errorBody;\n    try {\n      errorBody = contentType && contentType.includes(\"application/json\") ? await response.json() : await response.text();\n    } catch {\n      errorBody = await response.text();\n    }\n    // gestione robusta della stringificazione\n    let stringifiedErrorBody;\n    try {\n      stringifiedErrorBody = JSON.stringify(errorBody);\n    } catch (e) {\n      stringifiedErrorBody = String(errorBody);\n    }\n    throw new Error(`errore http! status: ${response.status}, body: ${stringifiedErrorBody}`);\n  }\n  if (contentType && contentType.includes(\"application/json\")) {\n    return response.json();\n  } else {\n    const text = await response.text();\n    throw new Error(`risposta non-json, body: ${text}`);\n  }\n}","map":{"version":3,"names":["apiFetch","url","options","token","localStorage","getItem","console","log","headers","Authorization","body","response","fetch","contentType","get","ok","errorBody","includes","json","text","stringifiedErrorBody","JSON","stringify","e","String","Error","status"],"sources":["C:/Users/aless/Lavoro/workspace/pokemonweb/frontend/src/services/api.js"],"sourcesContent":["// funzione helper per effettuare richieste autenticata con il token jwt\r\nexport async function apiFetch(url, options = {}) {\r\n  // recupero il token dal localstorage\r\n  const token = localStorage.getItem('token');\r\n  console.log('Token inviato nella richiesta:', token); \r\n  // aggiungo l'header authorization se il token è presente\r\n  const headers = {\r\n    ...(options.headers || {}),\r\n    ...(token ? { Authorization: `Bearer ${token}` } : {}),\r\n  };\r\n  // se c'è un body e non è già impostato, aggiungo content-type\r\n  if (options.body && !headers['Content-Type']) {\r\n    headers['Content-Type'] = 'application/json';\r\n  }\r\n  const response = await fetch(url, { ...options, headers });\r\n  const contentType = response.headers.get(\"content-type\");\r\n  if (!response.ok) {\r\n    // provo a leggere json, altrimenti testo\r\n    let errorBody;\r\n    try {\r\n      errorBody = contentType && contentType.includes(\"application/json\")\r\n        ? await response.json()\r\n        : await response.text();\r\n    } catch {\r\n      errorBody = await response.text();\r\n    }\r\n    // gestione robusta della stringificazione\r\n    let stringifiedErrorBody;\r\n    try {\r\n      stringifiedErrorBody = JSON.stringify(errorBody);\r\n    } catch (e) {\r\n      stringifiedErrorBody = String(errorBody);\r\n    }\r\n    throw new Error(\r\n      `errore http! status: ${response.status}, body: ${stringifiedErrorBody}`\r\n    );\r\n  }\r\n  if (contentType && contentType.includes(\"application/json\")) {\r\n    return response.json();\r\n  } else {\r\n    const text = await response.text();\r\n    throw new Error(`risposta non-json, body: ${text}`);\r\n  }\r\n}"],"mappings":"AAAA;AACA,OAAO,eAAeA,QAAQA,CAACC,GAAG,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EAChD;EACA,MAAMC,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC;EAC3CC,OAAO,CAACC,GAAG,CAAC,gCAAgC,EAAEJ,KAAK,CAAC;EACpD;EACA,MAAMK,OAAO,GAAG;IACd,IAAIN,OAAO,CAACM,OAAO,IAAI,CAAC,CAAC,CAAC;IAC1B,IAAIL,KAAK,GAAG;MAAEM,aAAa,EAAE,UAAUN,KAAK;IAAG,CAAC,GAAG,CAAC,CAAC;EACvD,CAAC;EACD;EACA,IAAID,OAAO,CAACQ,IAAI,IAAI,CAACF,OAAO,CAAC,cAAc,CAAC,EAAE;IAC5CA,OAAO,CAAC,cAAc,CAAC,GAAG,kBAAkB;EAC9C;EACA,MAAMG,QAAQ,GAAG,MAAMC,KAAK,CAACX,GAAG,EAAE;IAAE,GAAGC,OAAO;IAAEM;EAAQ,CAAC,CAAC;EAC1D,MAAMK,WAAW,GAAGF,QAAQ,CAACH,OAAO,CAACM,GAAG,CAAC,cAAc,CAAC;EACxD,IAAI,CAACH,QAAQ,CAACI,EAAE,EAAE;IAChB;IACA,IAAIC,SAAS;IACb,IAAI;MACFA,SAAS,GAAGH,WAAW,IAAIA,WAAW,CAACI,QAAQ,CAAC,kBAAkB,CAAC,GAC/D,MAAMN,QAAQ,CAACO,IAAI,CAAC,CAAC,GACrB,MAAMP,QAAQ,CAACQ,IAAI,CAAC,CAAC;IAC3B,CAAC,CAAC,MAAM;MACNH,SAAS,GAAG,MAAML,QAAQ,CAACQ,IAAI,CAAC,CAAC;IACnC;IACA;IACA,IAAIC,oBAAoB;IACxB,IAAI;MACFA,oBAAoB,GAAGC,IAAI,CAACC,SAAS,CAACN,SAAS,CAAC;IAClD,CAAC,CAAC,OAAOO,CAAC,EAAE;MACVH,oBAAoB,GAAGI,MAAM,CAACR,SAAS,CAAC;IAC1C;IACA,MAAM,IAAIS,KAAK,CACb,wBAAwBd,QAAQ,CAACe,MAAM,WAAWN,oBAAoB,EACxE,CAAC;EACH;EACA,IAAIP,WAAW,IAAIA,WAAW,CAACI,QAAQ,CAAC,kBAAkB,CAAC,EAAE;IAC3D,OAAON,QAAQ,CAACO,IAAI,CAAC,CAAC;EACxB,CAAC,MAAM;IACL,MAAMC,IAAI,GAAG,MAAMR,QAAQ,CAACQ,IAAI,CAAC,CAAC;IAClC,MAAM,IAAIM,KAAK,CAAC,4BAA4BN,IAAI,EAAE,CAAC;EACrD;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}